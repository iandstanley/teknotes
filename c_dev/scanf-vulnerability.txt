
                       SCANF VULNERABILITY



	#include <stdio.h>
	#include <string.h>

	int main() {

		char myinput[12];
		char mypassword[12] = "password123";

		scanf("%s", myinput);

		if ( strcmp( myinput, mypassword ) == 0 ) {

			printf("SUCCESS!");
		} else {
			printf("FAILURE!");
		}

		return 0;
	}





	$ gcc main.c

	$ ./a.out < <(python -c "print('AAAA');" )
	FAILURE!

	$ ./a.out < <(python -c "print('AAAAAAAAAAA' + '\x00' + 'AAAAAAAAAAA' + '\x00');" )
	SUCCESS!



A simpleway to stop this is by carefully setting the scanf() format string:

	scanf("%12s", myinput);

With this format string we cannot overwrite the buffer as scanf
ignores everything after the 12 bytes (and replaces 12th with '\0').





	/* read a line of text */

	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>

	int main() {

		char text[100];

		printf("Type a line of text");

		/*
			We want to avoid scanf from adding the
			carriage return '\n' to our string
		*/

		scanf("%[^\n]s", text);

		/*
  			Or more securely ...
  
  			scanf("%[^\n]20s", text);
  
  			which will limit input to 20 chars
  
		*/

		printf("You typed: %s\n", text);

		return 0;
	}



But if you try to run this twice with a second scanf to another
variable we see something bad happens.

Here scanf is leaving '\n' onthe input stream buffer.

So we need to flush the '\n' on the buffer before the second scanf()
call.

We could use the hack getch() to clear the '\n'.


An alternative is to use fgets() lets you specify both the stream
input but also how many characters we want to receive.  The last
char in the fgets() read is assigned '\0' to close off the string.
The function fgets() discards the rest of any input given by the
user.

Be careful of gets() though as it allows you to overrun buffers.



